<head>
<title>
map versus GNU parallel
</title>
<style>
    body        { background: #fff; margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; margin-left: -30px;   border-top:    5px  solid #ccc; }
    h2          { background: #ffb; margin-left: -20px;   border-top:    3px  solid #ddd; }
    h3          { background: #ffb; margin-left: -10px; }
    h4          { background: #ffb; }
    code        { font-size:    1.1em;  background:  #ddf; }
    pre         { margin-left:  2em;    background:  #ddf; }
    pre code    { font-size:    1.1em;  background:  #ddf; }
</style>

</head>

<p style="text-align:center">
    <a href="master-toc.html">master TOC</a>
|
    <a href="master-toc.html#map-vs-gp">chapter TOC</a>
|
    <a href="support.html">support</a>
</p>

<!-- file: mapgp "map versus GNU parallel" -->

<h1>map versus GNU parallel</h1>

<ul>
<li><a href="#map_vs_gp_detailed_list_of_examples_">detailed list of examples</a></li>
<li><a href="#cantwont">things that map cannot/will not do</a></li>
</ul>

<p>Here's a feature comparision of map versus GNU parallel, mostly using examples
in their <a href="http://www.gnu.org/software/parallel/man.html">man page</a>.</p>

<p>I got tired of trying these examples at about half way through their list.
The examples were getting more and more "kitchen sink"-ish (I mean, an option
called '--return' to get back a file from a remote computer?  I know "GNU is
Not Unix" but this is too much!)</p>

<p>It seems to match almost all the examples upto the halfway point of their set,
despite having only 3 options to remember, compared to almost a 100.</p>

<p><a name="map_vs_gp_detailed_list_of_examples_"></a></p>

<h2>detailed list of examples</h2>

<p>(Note: we're omitting the examples that talk about spaces in filenames, using
the null character, etc., because I didn't have the energy to test them
rigorously).</p>

<p>First we create test data:</p>

<pre><code>seq 1 10 | map -p 3 dd if=/dev/urandom bs=1M count=20 of=test-%.in
</code></pre>

<p>That creates 10 files, 3 at a time.</p>

<p><strong>Example: parallel gzip</strong></p>

<pre><code>ls *.in | map -p 5 gzip
# default % added at the end due to '-p'
</code></pre>

<p>They both run 5 jobs at the same time, each with one argument.  You can do
them in other ways:</p>

<p><strong>Example: reading arguments from command line</strong></p>

<p>No special syntax is required for this.  If STDIN is a tty, map's idea of what
is the command and what are its arguments changes:</p>

<pre><code>map -p 3 -n 3 gzip *.in
# default back to %% due to '-n'
</code></pre>

<p>This will pick up 3 arguments per job, 3 jobs in parallel.</p>

<p><strong>Example: Inserting multiple arguments</strong></p>

<p>As you saw in the "%" and "%%" comments above, inserting multiple arguments is
just using %% instead of %:</p>

<pre><code>ls *.in | map mv %% DESTDIR
</code></pre>

<p><strong>Example: context replace</strong></p>

<p>Again, we dont need all this extra syntax, so (using echo instead of rm for
testing):</p>

<pre><code>seq 1 10 | map echo test-%.in
</code></pre>

<p>which runs 10 individual jobs like their first example, and</p>

<pre><code>seq 1 10 | map echo test-%%.in
</code></pre>

<p>will run in one shot, and if you changed that 10 to 5000 or something it will
separate them when the command length has grown beyond 60,000 characters.</p>

<p><strong>Compute intensive jobs and substitution</strong></p>

<p>Keeping the basic structure of his commands, we'll do this.</p>

<p>First we take out 10 test data files and move some of them into
subdirectories:</p>

<pre><code>mkdir aa bb bb/cc
mv *10* aa; mv *5* bb; mv *2* *4* bb/cc
</code></pre>

<p>Now the find example:</p>

<pre><code>find . -name '*.in' | map -p dd if=% of=%D/%B_swabbed.in conv=swab
</code></pre>

<p>As you can see, we use %D etc instead of their <code>{.}</code>.  In fact, our <code>%</code> is
always exactly the same as <code>%D/%B.%E</code> (directory, basename, extension).</p>

<p><strong>Substitution and redirection</strong></p>

<p>First I gzip the existing files to provide the input to this step, then:</p>

<pre><code>map -p "zcat % &gt; %B" *.gz
</code></pre>

<p><strong>Example: composed commands</strong></p>

<pre><code>ls | map 'echo -ne %"\t"; ls %|wc -l'

ls | map '( echo -ne %"\t"; ls %|wc -l ) &gt; %.dir'
</code></pre>

<p>I didn't do the next 2; they seemed boring and not really clean.  The URLs one
was nice, but why waste all that bandwidth (and also needlessly write the damn
files to disk)?</p>

<pre><code>cat urls |map -p 'HEAD % &amp;&gt;/dev/null || grep -n % urls'
</code></pre>

<p>I skipped the mirror files one, but here's the one about files in a list that
do not exist:</p>

<pre><code>cat files | map -p '[ -e % ] || echo %'
</code></pre>

<p><strong>Example: removing file extension...</strong></p>

<pre><code>ls *.zip | map -p 'mkdir %B; cd %B; unzip -q ../%'

map -p 'zcat % |bzip2 &gt; %B.bz2 &amp;&amp; rm %' *.gz
</code></pre>

<p><strong>Example: remove 2 file extensions, calling map from itself</strong></p>

<pre><code>ls -d *.tar.gz | map echo %B | map -v 'mkdir %B; tar -xf %.gz'
</code></pre>

<p><strong>Example: download 10 images for past 30 days</strong></p>

<p>It's basically doing a loop within a loop.  Seems like a built-in operation at
some level in GNU parallel but we can do it too.  We'll do it with an 'echo'
instead of 'wget':</p>

<pre><code>seq 30 | map 'seq -w 10 | map -n 1 echo today -%, picture'
</code></pre>

<p>The first seq puts out a number that replaced the sole '%' sign in the whole
map, while the second has an implicit '%' at the end due to the '-n 1'.</p>

<p><strong>Example: Rewriting a for-loop and a while...</strong></p>

<p>pretty trivial; there are many examples earlier.  In the vein of their
example:</p>

<pre><code>cat list | map -p 'do1 % scale %B.jpg; do2 &lt; % %B'
</code></pre>

<p><strong>Example: Rewriting nested-for loops</strong></p>

<p>See earlier example "download 10 images..." -- you can use the same solution
here.  As I said there, GNU parallel seems to have special syntax for this; we
actually pipe a map to another one.</p>

<p><strong>Example: Group output lines</strong></p>

<p>We can't do this.  Without explicit redirection of some kind we may never be
able to.  This is because we get our parallelism using xargs.</p>

<p>(Also the next 2 examples)</p>

<p><strong>Example: parallel grep</strong></p>

<p>Easy enough to do; but it doesn't make sense to me to parallelise something
that will be IO-bound anyway; in all my tests it comes out slower to do this.</p>

<p><strong>Example: using remote computers</strong></p>

<p>...nope, we can't do it!</p>

<p><strong>Example: run the same command 10 times</strong></p>

<p>force it to go through xargs and put in a comment character after the command
you want:</p>

<pre><code>seq 10 | map -p 1 cmd \# boo
</code></pre>

<p><strong>Example: working as cat|sh</strong></p>

<pre><code>cat cmdlist | map -p 100 %
</code></pre>

<p><a name="cantwont"></a></p>

<h2>things that map cannot/will not do</h2>

<p>(this is only from the examples list; I haven't read the full options list,
reasoning that if an option were indispensable they'd have an example for it
anyway)</p>

<ul>
<li><p>see note above on filenames with unusual characters.  You do need to do
some extra quoting if you want to use parallel mode or compound/shell
commands.</p></li>
<li><p>map can't do "group output" when running parallelly.  You can use some
tricks if you really need it, like:</p>

<pre><code>... | map -p 4 'some-cmd % 2&gt;&amp;1 | sed -e "s/^/$$:/"' | sort | cut -f2- -d:
</code></pre>

<p>I don't need this feature enough to do more than that.</p>

<p>Besides, according to their manpage this takes a lot of CPU (why???),
compared to not grouping the output.  My workaround clearly doesn't --
unless the output is too big for sort I suppose.</p></li>
<li><p>same for "tagging output lines", and "keeping order ... the same ...",
although the latter is also achieved by the previous workaround.</p></li>
<li><p>map can't handle multiple inputs in one command.  However, their example
is easy enough with map's "delimiter mode":</p>

<pre><code>ls *.tar.* | perl -ne 'chomp; print; s/\.tar//; print " $_\n"' | map -d -- cp %1 %2
</code></pre>

<p>As you can see, there was no need to put the inputs into separate files
anyway.  If I find a genuine need I'll think about it...</p></li>
<li><p>map can't spread STDIN breadthwise among the available jobs, nor split the
data into chunks to spread.</p></li>
<li><p><strong>NO KITCHEN SINK</strong></p>

<ul>
<li>no '--sshlogin' to login to remote computers</li>
<li>no '--transfer' to transfer files</li>
<li><em>definitely</em> no '--return' to get those files back</li>
<li>no '--cleanup'</li>
<li><em>definitely</em> no '--trc' as shorthave for previous 3, heh!</li>
<li>and last but not least, we're not a 'semaphore' program!</li>
</ul></li>
</ul>
